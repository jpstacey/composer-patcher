<?php

/**
 * @file
 * Patcher: composer plugin to patch files post-download.
 */

namespace Composer\Patcher;

use Composer\Composer;
use Composer\IO\IOInterface;
use Composer\Plugin\PluginInterface;

use Composer\Script\Event;
use Composer\Util\RemoteFileSystem;
use Composer\Util\ProcessExecutor;

/**
 * Plugin scripted, but implements PluginInterface to ensure loaded early.
 */
class PatcherPlugin implements PluginInterface
{
    // Class static properties.
    public static $io;
    public static $executor;
    private static $fileRefs = array();

    /**
     * Implements PluginInterface::activate().
     *
     * Currently does nothing: postPackageInstall() below does heavy lifting.
     */
    public function activate(Composer $composer, IOInterface $io)
    {
    }

    /**
     * Implements scripts class method postPackageInstall().
     *
     * After package install, interrogates patch JSON array and applies.
     */
    public static function postPackageInstall(Event $event)
    {
        // Disable as composer's API has changed too much for this to still work.
        self::writeAndCloseReport("jpstacey/composer-patcher is now deprecated in favour of netresearch/composer-patches-plugin")
        return;
        
        // Store some objects from the event on this class.
        self::$io = $event->getIO();

        // Obtain install path, so as to patch within it.
        $package = $event->getOperation()->getPackage();
        $manager = $event->getComposer()->getInstallationManager();
        $installPath = $manager->getInstaller($package->getType())->getInstallPath($package);

        // Get list of patch URLs from "extra": { "patch": [ ... ]}.
        $extraData = $package->getExtra();
        if (!isset($extraData["patch"]) || !count($extraData["patch"]))
        {
            return;
        }

        // Begin patches report
        self::writeReport("The following patches have been applied to this project:", $installPath);

        // Descend into install directory, loop over patches and apply.
        $downloader = new RemoteFilesystem(self::$io, $event->getComposer()->getConfig());
        foreach ($extraData["patch"] as $patchUrl)
        {
            self::getAndApplyPatch($downloader, $installPath, $patchUrl);
            self::writeReport("- $patchUrl", $installPath);
        }

        // End patches report.
        self::writeAndCloseReport("\nThis file was automatically generated by Composer Patcher\n(https://github.com/jpstacey/composer-patcher)", $installPath);
    }

    /**
     * Apply a remote patch on code in the specified directory.
     */
    private static function getAndApplyPatch(RemoteFilesystem $downloader, $projectDirectory, $patchUrl)
    {
        // Generate random (but not cryptographically so) filename.
        $filename = uniqid("/tmp/") . ".patch";

        // Download file from remote filesystem to this location.
        $hostname = parse_url($patchUrl, PHP_URL_HOST);
        $downloader->copy($hostname, $patchUrl, $filename, TRUE);

        // Modified from drush6:make.project.inc
        $patched = FALSE;
        $patchLevels = array('-p1', '-p0');

        foreach ($patchLevels as $patchLevel)
        {
            $checked = self::executeCommand('cd %s && GIT_DIR=. git apply --check %s %s --verbose', $projectDirectory, $patchLevel, $filename);
            if ($checked)
            {
                // Apply the first successful style.
                $patched = self::executeCommand('cd %s && GIT_DIR=. git apply %s %s --verbose', $projectDirectory, $patchLevel, $filename);
                break;
            }   
        }   

        // In some rare cases, git will fail to apply a patch, fallback to using
        // the 'patch' command.
        if (!$patched)
        {
            foreach ($patchLevels as $patchLevel)
            {
                // --no-backup-if-mismatch here is a hack that fixes some
                // differences between how patch works on windows and unix.
                if ($patched = self::executeCommand("patch %s --no-backup-if-mismatch -d %s < %s", $patchLevel, $projectDirectory, $filename))
                {
                  break;
                }   
            }
        }

        // Remove patch file now, in case the exception below prevents us.
        unlink($filename);

        if (!$patched)
        {
            throw new \Exception("Cannot apply patch $patchUrl");
        }
    }

    /**
     * Execute a shell command with escaping.
     */
    private static function executeCommand($cmd)
    {
        // Get a process executor for running command lines below.
        if (!isset(self::$executor))
        {
            self::$executor = new ProcessExecutor(self::$io);
        }

        // Shell-escape all arguments except the command.
        $args = func_get_args();
        for ($x = 1; $x < sizeof($args); $x++)
        {
            $args[$x] = escapeshellarg($args[$x]);
        }
        // And replace the arguments.
        $command = call_user_func_array('sprintf', $args);

        return (self::$executor->execute($command) == 0);
    }

    /**
     * Log a message to a PATCHES.txt file.
     */
    private static function writeReport($message, $directory)
    {
        // Optionally open a file resource and store using its realpath().
        touch("$directory/PATCHES.txt");
        $filepath = realpath("$directory/PATCHES.txt");
        if (!isset(self::$fileRefs[$filepath]))
        {
            self::$fileRefs[$filepath] = fopen($filepath, "w");
        }

        // Write line to it.
        fwrite(self::$fileRefs[$filepath], "$message\n");
    }

    /**
     * Close PATCHES.txt file.
     */
    private static function writeAndCloseReport($message, $directory)
    {
        self::writeReport($message, $directory);
        fclose(self::$fileRefs[realpath("$directory/PATCHES.txt")]);
    }
}
